/*
 * Data
 *
 * With the Data service you can obtain additional data such as vehicle profiles.
 *
 * The version of the OpenAPI document: 1.6
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.data.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.data.Model
{
    /// <summary>
    /// A collection of roads and attributes to be assigned.
    /// </summary>
    [DataContract(Name = "RoadsToBeAttributed")]
    public partial class RoadsToBeAttributed : IEquatable<RoadsToBeAttributed>, IValidatableObject
    {

        /// <summary>
        /// Gets or Sets Direction
        /// </summary>
        [DataMember(Name = "direction", EmitDefaultValue = false)]
        public RoadDirectionType? Direction { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadsToBeAttributed" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RoadsToBeAttributed() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RoadsToBeAttributed" /> class.
        /// </summary>
        /// <param name="points">A point or a polyline to select roads.  For a single point the road closest to this point will be selected. Several points will be considered a polyline and all roads intersected by this polyline will be selected. The polyline must not be closed, i.e. the first and the last point must be different. To obtain best results a polyline should not cover more than one time zone. Ferries will not be selected.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline, * contains invalid coordinates, * covers no road or * covers more than 5000 roads. (required).</param>
        /// <param name="polylines">The polylines of the roads in the format specified by **polylineFormat**.  Only present in responses, will be ignored in requests..</param>
        /// <param name="direction">direction.</param>
        /// <param name="attributes">attributes (required).</param>
        /// <param name="validity">validity.</param>
        /// <param name="unmatchedAfterMapUpdate">If **roadsToBeAttributed** could not be matched to a new map after an update they are marked with this boolean flag. Unmatched **roadsToBeAttributed** might cause some unwanted changes of behavior for the scenario. This parameter must not be true if it is sent as part of a request. (default to false).</param>
        public RoadsToBeAttributed(string points = default(string), List<string> polylines = default(List<string>), RoadDirectionType? direction = default(RoadDirectionType?), RoadAttributes attributes = default(RoadAttributes), Validity validity = default(Validity), bool unmatchedAfterMapUpdate = false)
        {
            // to ensure "points" is required (not null)
            if (points == null)
            {
                throw new ArgumentNullException("points is a required property for RoadsToBeAttributed and cannot be null");
            }
            this.Points = points;
            // to ensure "attributes" is required (not null)
            if (attributes == null)
            {
                throw new ArgumentNullException("attributes is a required property for RoadsToBeAttributed and cannot be null");
            }
            this.Attributes = attributes;
            this.Polylines = polylines;
            this.Direction = direction;
            this.Validity = validity;
            this.UnmatchedAfterMapUpdate = unmatchedAfterMapUpdate;
        }

        /// <summary>
        /// A point or a polyline to select roads.  For a single point the road closest to this point will be selected. Several points will be considered a polyline and all roads intersected by this polyline will be selected. The polyline must not be closed, i.e. the first and the last point must be different. To obtain best results a polyline should not cover more than one time zone. Ferries will not be selected.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline, * contains invalid coordinates, * covers no road or * covers more than 5000 roads.
        /// </summary>
        /// <value>A point or a polyline to select roads.  For a single point the road closest to this point will be selected. Several points will be considered a polyline and all roads intersected by this polyline will be selected. The polyline must not be closed, i.e. the first and the last point must be different. To obtain best results a polyline should not cover more than one time zone. Ferries will not be selected.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline, * contains invalid coordinates, * covers no road or * covers more than 5000 roads.</value>
        [DataMember(Name = "points", IsRequired = true, EmitDefaultValue = true)]
        public string Points { get; set; }

        /// <summary>
        /// The polylines of the roads in the format specified by **polylineFormat**.  Only present in responses, will be ignored in requests.
        /// </summary>
        /// <value>The polylines of the roads in the format specified by **polylineFormat**.  Only present in responses, will be ignored in requests.</value>
        [DataMember(Name = "polylines", EmitDefaultValue = false)]
        public List<string> Polylines { get; set; }

        /// <summary>
        /// Gets or Sets Attributes
        /// </summary>
        [DataMember(Name = "attributes", IsRequired = true, EmitDefaultValue = true)]
        public RoadAttributes Attributes { get; set; }

        /// <summary>
        /// Gets or Sets Validity
        /// </summary>
        [DataMember(Name = "validity", EmitDefaultValue = false)]
        public Validity Validity { get; set; }

        /// <summary>
        /// If **roadsToBeAttributed** could not be matched to a new map after an update they are marked with this boolean flag. Unmatched **roadsToBeAttributed** might cause some unwanted changes of behavior for the scenario. This parameter must not be true if it is sent as part of a request.
        /// </summary>
        /// <value>If **roadsToBeAttributed** could not be matched to a new map after an update they are marked with this boolean flag. Unmatched **roadsToBeAttributed** might cause some unwanted changes of behavior for the scenario. This parameter must not be true if it is sent as part of a request.</value>
        [DataMember(Name = "unmatchedAfterMapUpdate", EmitDefaultValue = true)]
        public bool UnmatchedAfterMapUpdate { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RoadsToBeAttributed {\n");
            sb.Append("  Points: ").Append(Points).Append("\n");
            sb.Append("  Polylines: ").Append(Polylines).Append("\n");
            sb.Append("  Direction: ").Append(Direction).Append("\n");
            sb.Append("  Attributes: ").Append(Attributes).Append("\n");
            sb.Append("  Validity: ").Append(Validity).Append("\n");
            sb.Append("  UnmatchedAfterMapUpdate: ").Append(UnmatchedAfterMapUpdate).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RoadsToBeAttributed);
        }

        /// <summary>
        /// Returns true if RoadsToBeAttributed instances are equal
        /// </summary>
        /// <param name="input">Instance of RoadsToBeAttributed to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RoadsToBeAttributed input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Points == input.Points ||
                    (this.Points != null &&
                    this.Points.Equals(input.Points))
                ) && 
                (
                    this.Polylines == input.Polylines ||
                    this.Polylines != null &&
                    input.Polylines != null &&
                    this.Polylines.SequenceEqual(input.Polylines)
                ) && 
                (
                    this.Direction == input.Direction ||
                    this.Direction.Equals(input.Direction)
                ) && 
                (
                    this.Attributes == input.Attributes ||
                    (this.Attributes != null &&
                    this.Attributes.Equals(input.Attributes))
                ) && 
                (
                    this.Validity == input.Validity ||
                    (this.Validity != null &&
                    this.Validity.Equals(input.Validity))
                ) && 
                (
                    this.UnmatchedAfterMapUpdate == input.UnmatchedAfterMapUpdate ||
                    this.UnmatchedAfterMapUpdate.Equals(input.UnmatchedAfterMapUpdate)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Points != null)
                {
                    hashCode = (hashCode * 59) + this.Points.GetHashCode();
                }
                if (this.Polylines != null)
                {
                    hashCode = (hashCode * 59) + this.Polylines.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Direction.GetHashCode();
                if (this.Attributes != null)
                {
                    hashCode = (hashCode * 59) + this.Attributes.GetHashCode();
                }
                if (this.Validity != null)
                {
                    hashCode = (hashCode * 59) + this.Validity.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.UnmatchedAfterMapUpdate.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
