/*
 * Data
 * With the Data service you can obtain additional data such as vehicle profiles.
 *
 * The version of the OpenAPI document: 1.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.data.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.data.model.RoadAttributes;
import com.ptvgroup.developer.client.data.model.RoadDirectionType;
import com.ptvgroup.developer.client.data.model.Validity;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * A collection of roads and attributes to be assigned.
 */
@ApiModel(description = "A collection of roads and attributes to be assigned.")
@JsonPropertyOrder({
  RoadsToBeAttributed.JSON_PROPERTY_POINTS,
  RoadsToBeAttributed.JSON_PROPERTY_POLYLINES,
  RoadsToBeAttributed.JSON_PROPERTY_DIRECTION,
  RoadsToBeAttributed.JSON_PROPERTY_ATTRIBUTES,
  RoadsToBeAttributed.JSON_PROPERTY_VALIDITY,
  RoadsToBeAttributed.JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-10-30T06:51:07.244706Z[Etc/UTC]")
public class RoadsToBeAttributed {
  public static final String JSON_PROPERTY_POINTS = "points";
  private String points;

  public static final String JSON_PROPERTY_POLYLINES = "polylines";
  private List<String> polylines = null;

  public static final String JSON_PROPERTY_DIRECTION = "direction";
  private RoadDirectionType direction = RoadDirectionType.BOTH;

  public static final String JSON_PROPERTY_ATTRIBUTES = "attributes";
  private RoadAttributes attributes;

  public static final String JSON_PROPERTY_VALIDITY = "validity";
  private Validity validity;

  public static final String JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE = "unmatchedAfterMapUpdate";
  private Boolean unmatchedAfterMapUpdate = false;

  public RoadsToBeAttributed() { 
  }

  public RoadsToBeAttributed points(String points) {
    this.points = points;
    return this;
  }

   /**
   * A point or a polyline to select roads.  For a single point the road closest to this point will be selected. Several points will be considered a polyline and all roads intersected by this polyline will be selected. The polyline must not be closed, i.e. the first and the last point must be different. To obtain best results a polyline should not cover more than one time zone. Ferries will not be selected.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline, * contains invalid coordinates, * covers no road or * covers more than 5000 roads.
   * @return points
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A point or a polyline to select roads.  For a single point the road closest to this point will be selected. Several points will be considered a polyline and all roads intersected by this polyline will be selected. The polyline must not be closed, i.e. the first and the last point must be different. To obtain best results a polyline should not cover more than one time zone. Ferries will not be selected.  Format: `<point1_lat>,<point1_lon>,...,<pointN_lat>,<pointN_lon>`.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline, * contains invalid coordinates, * covers no road or * covers more than 5000 roads.")
  @JsonProperty(JSON_PROPERTY_POINTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getPoints() {
    return points;
  }


  @JsonProperty(JSON_PROPERTY_POINTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPoints(String points) {
    this.points = points;
  }


  public RoadsToBeAttributed polylines(List<String> polylines) {
    this.polylines = polylines;
    return this;
  }

  public RoadsToBeAttributed addPolylinesItem(String polylinesItem) {
    if (this.polylines == null) {
      this.polylines = new ArrayList<>();
    }
    this.polylines.add(polylinesItem);
    return this;
  }

   /**
   * The polylines of the roads in the format specified by **polylineFormat**.  Only present in responses, will be ignored in requests.
   * @return polylines
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The polylines of the roads in the format specified by **polylineFormat**.  Only present in responses, will be ignored in requests.")
  @JsonProperty(JSON_PROPERTY_POLYLINES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getPolylines() {
    return polylines;
  }


  @JsonProperty(JSON_PROPERTY_POLYLINES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPolylines(List<String> polylines) {
    this.polylines = polylines;
  }


  public RoadsToBeAttributed direction(RoadDirectionType direction) {
    this.direction = direction;
    return this;
  }

   /**
   * Get direction
   * @return direction
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_DIRECTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public RoadDirectionType getDirection() {
    return direction;
  }


  @JsonProperty(JSON_PROPERTY_DIRECTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDirection(RoadDirectionType direction) {
    this.direction = direction;
  }


  public RoadsToBeAttributed attributes(RoadAttributes attributes) {
    this.attributes = attributes;
    return this;
  }

   /**
   * Get attributes
   * @return attributes
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public RoadAttributes getAttributes() {
    return attributes;
  }


  @JsonProperty(JSON_PROPERTY_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAttributes(RoadAttributes attributes) {
    this.attributes = attributes;
  }


  public RoadsToBeAttributed validity(Validity validity) {
    this.validity = validity;
    return this;
  }

   /**
   * Get validity
   * @return validity
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_VALIDITY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Validity getValidity() {
    return validity;
  }


  @JsonProperty(JSON_PROPERTY_VALIDITY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setValidity(Validity validity) {
    this.validity = validity;
  }


  public RoadsToBeAttributed unmatchedAfterMapUpdate(Boolean unmatchedAfterMapUpdate) {
    this.unmatchedAfterMapUpdate = unmatchedAfterMapUpdate;
    return this;
  }

   /**
   * If **roadsToBeAttributed** could not be matched to a new map after an update they are marked with this boolean flag. Unmatched **roadsToBeAttributed** might cause some unwanted changes of behavior for the scenario. This parameter must not be true if it is sent as part of a request.
   * @return unmatchedAfterMapUpdate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If **roadsToBeAttributed** could not be matched to a new map after an update they are marked with this boolean flag. Unmatched **roadsToBeAttributed** might cause some unwanted changes of behavior for the scenario. This parameter must not be true if it is sent as part of a request.")
  @JsonProperty(JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getUnmatchedAfterMapUpdate() {
    return unmatchedAfterMapUpdate;
  }


  @JsonProperty(JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUnmatchedAfterMapUpdate(Boolean unmatchedAfterMapUpdate) {
    this.unmatchedAfterMapUpdate = unmatchedAfterMapUpdate;
  }


  /**
   * Return true if this RoadsToBeAttributed object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RoadsToBeAttributed roadsToBeAttributed = (RoadsToBeAttributed) o;
    return Objects.equals(this.points, roadsToBeAttributed.points) &&
        Objects.equals(this.polylines, roadsToBeAttributed.polylines) &&
        Objects.equals(this.direction, roadsToBeAttributed.direction) &&
        Objects.equals(this.attributes, roadsToBeAttributed.attributes) &&
        Objects.equals(this.validity, roadsToBeAttributed.validity) &&
        Objects.equals(this.unmatchedAfterMapUpdate, roadsToBeAttributed.unmatchedAfterMapUpdate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(points, polylines, direction, attributes, validity, unmatchedAfterMapUpdate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RoadsToBeAttributed {\n");
    sb.append("    points: ").append(toIndentedString(points)).append("\n");
    sb.append("    polylines: ").append(toIndentedString(polylines)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    validity: ").append(toIndentedString(validity)).append("\n");
    sb.append("    unmatchedAfterMapUpdate: ").append(toIndentedString(unmatchedAfterMapUpdate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

